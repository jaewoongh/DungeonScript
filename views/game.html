<!--
   ______                      _ __         __   ______                   
  / ____/___  ____ ___  ____  (_) /__  ____/ /  / ____/___ _____ ___  ___ 
 / /   / __ \/ __ `__ \/ __ \/ / / _ \/ __  /  / / __/ __ `/ __ `__ \/ _ \
/ /___/ /_/ / / / / / / /_/ / / /  __/ /_/ /  / /_/ / /_/ / / / / / /  __/
\____/\____/_/ /_/ /_/ .___/_/_/\___/\__,_/   \____/\__,_/_/ /_/ /_/\___/ 
                    /_/                                                   
 Main game script that has setup and loop
  Written by Jaewoong Hwang (http://jaewoong.info)
   May 2014
//-->

<div id="gameContainer" style="position:absolute;top:10px;bottom:10px;left:10px;right:10px;">
</div>

<script src="js/texthelper.js"></script>

<script>
/*  ____ _    ____ ___  ____ _       _  _ ____ ____ _ ____ ___  _    ____ ____ 
    | __ |    |  | |__] |__| |       |  | |__| |__/ | |__| |__] |    |___ [__  
    |__] |___ |__| |__] |  | |___     \/  |  | |  \ | |  | |__] |___ |___ ___]  */

    var things = [];    // Key array that holds every THINGS
    var todo = [];      // Things that would happen at the end of the loop
    var loopTimer;      // Interval timer -- may be removed for the sake of pause

    var canvas;         // Main game canvas
    var ctx;            // Main game canvas context


/*  ____ _  _ ____ ____ _   _    ____ _  _ _  _ ____ ___ _ ____ _  _ 
    |  | |  | |___ |__/  \_/     |___ |  | |\ | |     |  | |  | |\ | 
    |_\| |__| |___ |  \   |      |    |__| | \| |___  |  | |__| | \| 

    The only basic function for the entire system.
    Retrieve THINGS that matches conditions, and deal with them.

    Usage: 
        queryThings({ match:charm, maybe:onemore });
            -> Return thing(s) that matches conditions
            -> For use of: { charm: @thing }

        queryThings({ match:charm }, function(sender) {
            this.charm = isNowThis;
            this.theOther = sender.charm;
        });
            -> Get thing(s) that matches conditions, and do something with it(them) and possibly a sender.
            -> For use of: query { .do: something }
            -> For use of: query { toOtherThings <~ { .do: aThing, .or: ~more } }   */

    var queryThings = function() {
        // arguments[0] should be a query object, while arguments[1] being callback function
        var query = arguments[0] || {};
        var callback = arguments[1] || undefined;

        var result = [];
        for(var i = 0; i < things.length; i++) {
            result.push(things[i]);     // Assume that the thing satisifies queries, and discard later when it does not
            for(var key in query) {
                if(!query.hasOwnProperty(key)) continue;
                if((things[i][key] !== undefined) === (query[key] === undefined)) {
                // If there's no CHARM for query or there is a CHARM for !query,
                    result.pop();
                    break;
                } else if(things[i][key]) {
                // If there's a CHARM for query
                    if(typeof query[key] === 'function') {
                        if(!query[key](things[i][key])) {
                            result.pop();
                            break;
                        }
                    } else {
                        if(query[key] !== true && things[i][key] !== query[key]) {
                            result.pop();
                            break;
                        }
                    }
                }
            }
        }

        if(callback) {
            // Call callback function with scope
            for(var i = 0; i < result.length; i++) {
                callback.call(result[i], this);
            }
        } else {
            // Or just return the first matched THING
            return result[0];
        }
    };


/*  ____ ____ ___ 
    [__  |___  |  
    ___] |___  |    */

    var setGame = function() {
        // Set default meta data
        things.push({
            meta:           true,
            title:          'untitled',
            author:         'unknown',
            tick:           200,
            font:           undefined,
            targetWidth:    800,
            targetHeight:   600,
            /* fixed-size:  true */
        });

        // Override meta data if needed
        {{{ meta }}}

        // Set canvas
        canvas = document.createElement('canvas');
        var meta = queryThings({meta:true});
        if(meta.fixed$size === true) {
            canvas.width = meta.targetWidth;
            canvas.height = meta.targetHeight;
        } else {
            resizeCanvas(meta.targetWidth, meta.targetHeight);
        }
        ctx = canvas.getContext('2d');
        document.getElementById('gameContainer').appendChild(canvas);

        // Set things
        {{{ set }}}

        // Set loop timer
        loopTimer = setInterval(loopGame, queryThings({meta:true}).tick);
    };


/*  _    ____ ____ ___  
    |    |  | |  | |__] 
    |___ |__| |__| |        */

    var loopGame = function() {
        // Fill out canvas
        ctx.rect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#000000';
        ctx.fill();

        // Run to-do, and reset it
        for(var i = 0; i < todo.length; i++) {
            todo[i]();
        }
        todo = [];

        // Run loop code
        {{{ loop }}}

        // Deal with built-in behaviors
        for(var i = 0; i < things.length; i++) {
            for(var key in things[i]) {
                if(!things[i].hasOwnProperty(key)) continue;
                switch(key) {
                    /* Show text on canvas
                        text ─┬─ show
                              ├─ x: number relative to screen width
                              ├─ y: number relative to screen height
                              ├─ wrap-width: number relative to screen width
                              ├─ wrap-height: number relative to screen height
                              ├─ text-align: start / end / center / left / right
                              ├─ font: "Helvetica"
                              ├─ font-size: number relative to screen height
                              └─ font-color: "#nnnnnn"  */
                    case 'text':
                        if(!things[i]['show']) break;
                        var textOption = {
                            text: things[i]['text'] || '',
                            x: things[i]['x'] || 0,
                            y: things[i]['y'] || 0.05,
                            wrap$width: things[i]['wrap$width'] || 0,
                            wrap$height: things[i]['wrap$height'] || 0,
                            text$align: things[i]['text$align'] || 'start',
                            font: things[i]['font'] || 'Andale Mono',
                            font$size: things[i]['font$size'] || 0.05,
                            font$color: things[i]['font$color'] || '#ffffff'
                        };
                        textHelper.drawText(ctx, textOption);
                        break;

                    // TODO here
                }
            }
        }
    };


/*  ____ ___ _  _ ____ ____ ____ 
    |  |  |  |__| |___ |__/ [__  
    |__|  |  |  | |___ |  \ ___]    */

    var resizeCanvas = function(tWidth, tHeight) {
        var gc = document.getElementById('gameContainer');
        if(tWidth/tHeight >= gc.offsetWidth/gc.offsetHeight) {
            canvas.width = gc.offsetWidth;
            canvas.height = gc.offsetWidth * tHeight / tWidth;
            canvas.setAttribute('style', 'position:absolute;top:'+(gc.offsetHeight-canvas.height)*0.5+'px');
        } else {
            canvas.height = gc.offsetHeight;
            canvas.width = gc.offsetHeight * tWidth / tHeight;
            canvas.setAttribute('style', 'position:absolute;left:'+(gc.offsetWidth-canvas.width)*0.5+'px');
        }
    };


    window.onresize = function() {
        var meta = queryThings({meta:true});
        resizeCanvas(meta.targetWidth, meta.targetHeight);
    };

    window.onload = function() {
        setGame();
    };
</script>